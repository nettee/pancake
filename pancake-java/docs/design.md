# 模块设计

由于本项目是受到斯坦福 [CS346][cs346] 课程中 RedBase 的启发，因此模块设计和 RedBase 一致，包括五层结构：

+ **Paged File**: 最底层结构，将文件分为 **页** ，向上层模块提供文件I/O操作接口
+ **Record Management**: 在文件中存储 **记录** ，提供存取记录的功能
+ **Indexing**: 在无序的数据记录之上创建 **索引** ，用来加速记录的存取
+ **System Management**: 提供命令行工具，处理DDL命令
+ **Query Language**: 处理SQL查询语言

RedBase 项目是使用 C++ 实现的，而本项目使用 Java 实现，因此会有一些更 **面向对象** 的设计。但总体结构与 RedBase 相似。

## Paged File

Paged File (PF) 模块提供读写数据库文件功能。PF 模块将数据库文件划分成页，上层模块可通过一个 `PagedFile` 来对数据库文件进行操作。

### 页

`PagedFile` 提供 **页** 作为读写数据的单元。**页** 即一块固定大小的存储区域，数据文件被划分成一个个的页。上层模块对页进行读写，而不需要直接操纵数据文件。 一个页在文件中的大小为 4096 字节 (4KB) ，其中 4 字节用来存储页编号， 4092 字节用来存储数据，进行数据读写。

文件中的页通过 **页编号** 来标识。页编号从 0 开始，代表了页在数据文件中的位置。上层模块通过 **申请页** (`allocatePage()`) 来获得存储空间。当在一个新创建的 `PagedFile` 中申请页时，得到的页编号一定是从 0 开始 _连续的_ 。上层模块可以通过 **获取页** 的接口：`getFirstPage()` 和 `getNextPage()` 来遍历文件中所有的页。同样的，获取页时会得到从0开始连续的页编号。

当不再需要一个页的存储空间时，可以通过 `disposePage()` 来删除页。**删除页** 会导致页中的数据无效，并在遍历所有的页时出现页编号的缺失——遍历页时仍然会得到递增的页编号，但不一定连续，因为会跳过已删除的页。在有页被删除了以后，申请页时会分配到已删除的页。已删除的页的重新分配遵循 FILO 规则：在申请新页时，会优先分配最近删除的页。只有当所有已删除的页分配完后，才会在申请页时分配全新的页。

### 缓冲池

由于页实际上存在于数据文件中，因此要处理一个页中的数据，首先要将这个页读取到主存中。PF 模块维护一个 **缓冲池 (buffer pool)** ，用来放置需要进行处理的页。 缓冲池的容量上限为 40。

一个页在缓冲池中有 **pinned** / **unpinned** 两种状态。当使用 `allocatePage()` 申请页或使用 `getPage()` 获取页时，这个页会自动进入缓冲池，并处于 pinned 状态，表示它正在被处理。缓冲池中可容纳的 pinned 的页是有限的，当缓冲池已满时，将无法申请页或者获取页。因此，对一个页的操作结束后，需要及时使用 `unpinPage()` 将页标记为 unpinned ，即使在不久的将来还需要使用这个页。

一个页处理 unpinned 状态表示该页可以被移除出缓冲池，但并不意味着这个页会立即从缓冲池中移除。只有当缓冲池的空间不够时，才会移除 unpinned 的页，释放其内存空间以放置新的页。Unpinned 的页的移除顺序遵循最近未使用 (LRU) 规则。一个 unpinned 的页如果在被移除出缓冲池之前再次被 pin （通过 `getPage()`），则可以直接在缓冲池中使用这个页。Paged file 模块在关闭数据文件前会移除缓冲池中所有的页，因此上层模块必须在关闭数据文件之前，unpin 所有的页。

一个页在缓冲池中还有 **dirty** 状态。一个页处于 dirty 状态表示这个页的数据与磁盘中的数据文件不一致。因此，当对页中的数据进行修改（写操作时），需要使用 `markDirty()` 声明该页中的数据已经被修改或将会被修改。当缓冲池移除一个页时，只有 dirty 的页会 **写回** 至数据文件。写回操作默认发生在一个页从缓冲池中移除时，可以使用 `forcePage()` 来令一个页立即写回。

## Record Management

Record Management (RM) 模块提供管理无顺序的 **记录 (record)** 的功能。上层模块可通过对一个 `RecordFile` 进行操作来管理记录。RM 模块基于 PF 模块实现，每个 `RecordFile` 都对应于一个底层的 `PagedFile`。同时，RM 模块隐藏了 PF 模块的存在，上层模块无需对 `PagedFile` 进行操作。

RM 模块在 `PagedFile` 提供的页中进行记录的存储。每个 paged file 的第一个页会作为 **header page** ，存储元信息，包括记录的长度、记录的个数等。在创建 `RecordFile` 时，需要指定记录的长度。RM 模块目前要求同一个数据文件中只能存储相同长度的记录。不同长度的记录可以通过存储在不同的数据文件中解决。 

### 记录

一条记录即一个固定长度的字节数组。RM 模块提供了记录的增删查改 (CRUD) 功能。上层模块可通过 `insertRecord()`, `getRecord()`, `updateRecord()`, `deleteRecord()` 进行这些操作。

### 记录 ID (RID)

RM 模块将记录存储在 paged file 的不同页中，每个页中存储多条记录。这种情况下，**记录 ID (RID)** 为一个二元组 `(pageNum, slotNum)` ，其中 **页编号 (pageNum)** 表示记录所在的页，这个编号和 paged file 中的页编号相同； **槽编号 (slotNum)** 表示记录在该页中的序号。同一个页中的槽编号是从 0 开始连续的。

### 扫描记录

RM 模块提供了扫描记录的功能。一个扫描既可以扫描全部的记录，也可以扫描符合指定条件的记录。刷选条件是一个数值关系的比较，有六种比较符（EQ, LT, GT, LE, GE, NE）。

## 参考文档

+ [Stanford CS346 - Database System Implementation - Spring 2015][cs346]

[cs346]: https://web.stanford.edu/class/cs346/2015/
