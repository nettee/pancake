package me.nettee.pancake.core.page;

import org.junit.*;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Deque;

import static me.nettee.pancake.core.page.PagedFileTestUtils.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class PagedFileReopenTest {

	private static final Path path = Paths.get("/tmp/c.db");
	private PagedFile pagedFile;

	@BeforeClass
	public static void setUpBeforeClass() {

	}

	@Before
	public void setUp() throws IOException {
		Files.deleteIfExists(path);
		pagedFile = PagedFile.create(path);
	}

	@After
	public void tearDown() {
		pagedFile.close();
	}

	public void reopen() {
		pagedFile.close();
		pagedFile = PagedFile.open(path);
	}

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	@Test
	public void testNumberOfPages() {
		int N = allocatePages(pagedFile);
		unpinPages(pagedFile, N);
		reopen();
		assertEquals(N, pagedFile.getNumOfPages());
	}

    /**
     * All the allocated pages can be accessed.
     */
	@Test
	public void testPageNumberRange() {
		int N = allocatePages(pagedFile);
		unpinPages(pagedFile, N);
		reopen();
		for (int pageNum = 0; pageNum < N; pageNum++) {
			// except to be no exception
			pagedFile.getPage(pageNum);
		}
		unpinPages(pagedFile, N);
		thrown.expect(PagedFileException.class);
		pagedFile.getPage(N);
	}

    /**
     * All the allocated pages, except disposed ones, can be accessed.
     */
	@Test
	public void testDisposedPage() {
		int N = allocatePages(pagedFile);
		Deque<Integer> disposedPageNums = disposePages(pagedFile, N);
		unpinPages(pagedFile, N, disposedPageNums);
		reopen();
		for (int pageNum = 0; pageNum < N; pageNum++) {
			if (disposedPageNums.contains(pageNum)) {
				try {
					pagedFile.getPage(pageNum);
					fail("expect PagedFileException to throw");
				} catch (PagedFileException e) {
					// expected
				}
			} else {
				pagedFile.getPage(pageNum);
			}
		}
		unpinPages(pagedFile, N, disposedPageNums);
	}

    /**
     * The pageNums of disposed pages will be re-used for the following
	 * allocations. The reallocated pageNums follow the LIFO policy.
     */
	@Test
	public void testReallocateDisposedPage() {
		int N = allocatePages(pagedFile);
		Deque<Integer> disposedPageNums = disposePages(pagedFile, N);
		unpinPages(pagedFile, N, disposedPageNums);
		reopen();
		for (int i = 0; i < disposedPageNums.size(); i++) {
			Page page = pagedFile.allocatePage();
			int expectedPageNum = disposedPageNums.pop();
			assertEquals(expectedPageNum, page.num);
			pagedFile.unpinPage(page);
		}
	}

	// The pageNums are restored after re-open.
	@Test
	public void testGetPage() {
		String str0 = randomString();
		int N = allocatePages(pagedFile);
		fillPages(pagedFile, str0, N);
		unpinPages(pagedFile, N);
		reopen();
		for (int pageNum = 0; pageNum < N; pageNum++) {
			Page page = pagedFile.getPage(pageNum);
			String str = getStringData(page, str0.length() + String.valueOf(pageNum).length());
			assertEquals(str0, str.substring(0, str0.length()));
			assertEquals(pageNum, (int) Integer.valueOf(str.substring(str0.length())));
		}
		unpinPages(pagedFile, N);
	}
}
