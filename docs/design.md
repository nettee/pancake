# 模块设计

由于本项目是受到斯坦福 [CS346][cs346] 课程中 RedBase 的启发，因此模块设计和 RedBase 一致，包括五层结构：

+ **Paged File**: 最底层结构，将文件分为 **页** ，向上层模块提供文件I/O操作接口
+ **Record Management**: 在文件中存储 **记录** ，提供存取记录的功能
+ **Indexing**: 在无序的数据记录之上创建 **索引** ，用来加速记录的存取
+ **System Management**: 提供命令行工具，处理DDL命令
+ **Query Language**: 处理SQL查询语言

RedBase 项目是使用 C++ 实现的，而本项目使用 Java 实现，因此会有一些更 **面向对象** 的设计。但总体结构与 RedBase 相似。

## Paged File

数据文件被划分成大小相同的 **页** 来方便数据的存储。

### 缓冲池

要从一个页中读取数据，首先要将这个页读取到 **缓冲池 (buffer pool)** 中。我们定义一个页的 **pinned** / **unpinned** 状态。处于 pinned 状态表示这个页已经读取到了内存中，这时我们可以操作其中的数据。一个页不能被 pin 两次。当上层模块操作数据的工作结束时，应当将这个页 unpin。一个页不会自动变回 unpinned 状态，必须手动 unpin。上层模块必须保证使用完一个页后将其及时 unpin，即使在不久的将来还需要使用这个页。否则，将会造成内存泄漏类似的后果——缓冲池会被各种页所占据，最终甚至无法读取新的页。

Unpin 一个页并不意味着将这个页从缓冲池中移除，只有当缓冲池的空间不够时，才会将已经被 unpin 的页移除，释放其内存空间以放置新的页。这一过程遵循最近未使用 (LRU) 替换规则。

我们还定义一个页的 **dirty** 状态来表示它的数据有没有被修改过。当一个 **dirty** 的页从缓冲池中移除时，页中的数据将会写回至文件。一般而言，写回操作都是发生在一个页从缓冲池中移除时，除非上层模块可以强制要求页中的数据写回。

### 申请页、删除页、页编号

文件中的页通过编号（数字）来标识。页编号对应了页在数据文件中的位置。当你一开始为一个文件申请页时，得到的页编号应一定是 _连续的_ 。然而，如果有页被删除了，申请页时将会优先被分配到已删除的页编号。已删除的页的重新分配遵循 FILO 规则——在申请新页时，会优先分配最近删除的页。只有当已删除的页分配完后，才会分配新的页。

上层模块可以通过类似迭代器的接口：`GetFirstPage` 和 `GetNextPage` 来遍历文件中所有的页。遍历得到的页编号一定是 _递增的_ 。

### 一些注意事项

+ 一个页的大小为 4096 字节 (4KB) ，其中 4 字节用来存储页编号， 4092 字节用来存储数据。
+ 缓冲池应有容量上限，RedBase 中设置为 40
+ Paged File 模块处理所有的内存管理、文件管理工作，上层模块不需要也不应当直接管理缓冲池等内存。


## 参考文档

+ [Stanford CS346 - Database System Implementation - Spring 2015][cs346]

[cs346]: https://web.stanford.edu/class/cs346/2015/
