# 模块设计

由于本项目是受到斯坦福 [CS346][cs346] 课程中 RedBase 的启发，因此模块设计和 RedBase 一致，包括五层结构：

+ **Paged File**: 最底层结构，将文件分为 **页** ，向上层模块提供文件I/O操作接口
+ **Record Management**: 在文件中存储 **记录** ，提供存取记录的功能
+ **Indexing**: 在无序的数据记录之上创建 **索引** ，用来加速记录的存取
+ **System Management**: 提供命令行工具，处理DDL命令
+ **Query Language**: 处理SQL查询语言

RedBase 项目是使用 C++ 实现的，而本项目使用 Java 实现，因此会有一些更 **面向对象** 的设计。但总体结构与 RedBase 相似。

## Paged File

### 页

Paged file 对外提供 **页** 作为读写数据的单元。**页** 即一块固定大小 (4092 字节) 的存储区域，数据文件被划分成一个个的页。上层模块对页进行读写，而不需要直接操纵数据文件。

文件中的页通过 **页编号** 来标识。页编号从 0 开始，代表了页在数据文件中的位置。上层模块通过 **申请页** (`allocatePage()`) 来获得存储空间。当一开始为一个 paged file 申请页时，得到的页编号一定是从 0 开始 _连续的_ 。上层模块可以通过类似迭代器的接口：`getFirstPage()` 和 `getNextPage()` 来遍历文件中所有的页。同样的，**获取页** 时会得到从0开始 _连续的_ 页编号。

当不再需要一个页的存储空间时，可以通过 `disposePage()` 来删除页。**删除页** 会导致页中的数据无效，并在遍历所有的页时出现页编号的缺失——遍历页时仍然会得到递增的页编号，但不一定连续，因为会跳过已删除的页。在有页被删除了以后，申请页时会优先分配到已删除的页。已删除的页的重新分配遵循 FILO 规则：在申请新页时，会优先分配最近删除的页。只有当所有已删除的页分配完后，才会在申请页时分配全新的页。

### 缓冲池

由于页实际上存在于数据文件中，因此要处理一个页中的数据，首先要将这个页读取到主存中。Paged file 模块维护一个 **缓冲池 (buffer pool)** ，用来放置需要进行处理的页。

一个页在缓冲池中有 **pinned** / **unpinned** 两种状态。当使用 `allocatePage()` 申请页或使用 `getPage()` 获取页时，这个页会自动进行缓冲池，并处于 pinned 状态。一个页处于 pinned 状态意味着它正在被处理。缓冲池中可容纳的 pinned 的页是有限的，当缓冲池已满时，将无法申请页或者获取页。因此，对一个页的操作结束后，需要及时使用 `unpinPage()` 将页标记为 unpinned ，即使在不久的将来还需要使用这个页。

Unpin 一个页并不意味着将这个页从缓冲池中移除。只有当缓冲池的空间不够时，才会移除 unpinned 的页，释放其内存空间以放置新的页。Unpinned 的页的移除顺序遵循最近未使用 (LRU) 规则。Paged file 模块在关闭数据文件前会移除缓冲池中所有的页，因此只有当所有的页都被 unpin 之后，才能关闭数据文件。

一个页在缓冲池中还有 **dirty** 状态。一个页处于 dirty 状态表示这个页的数据与磁盘中的数据文件不一致。因此，当对页中的数据进行修改（写操作时），需要使用 `markDirty()` 表示该页中的数据已经被修改或将会被修改。当缓冲池移除一个页时，只有 dirty 的页会 **写回** 至数据文件。写回操作默认发生在一个页从缓冲池中移除时，可以使用 `forcePage()` 来令一个页立即写回。

### 一些常量

+ 一个页的大小为 4096 字节 (4KB) ，其中 4 字节用来存储页编号， 4092 字节用来存储数据。
+ 缓冲池应的容量上限为 40

## 参考文档

+ [Stanford CS346 - Database System Implementation - Spring 2015][cs346]

[cs346]: https://web.stanford.edu/class/cs346/2015/
